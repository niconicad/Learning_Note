以下是常见排序算法的性能对比总结，包括时间复杂度、空间复杂度及稳定性等关键指标：

### 1. **基础排序算法**

| 算法         | 最好时间复杂度   | 平均时间复杂度   | 最坏时间复杂度   | 空间复杂度   | 稳定性 | 特点                                                   |
| ------------ | ---------------- | ---------------- | ---------------- | ------------ | ------ | ------------------------------------------------------ |
| **冒泡排序** | O(n)O(n)O(n)     | O(n2)O(n^2)O(n2) | O(n2)O(n^2)O(n2) | O(1)O(1)O(1) | 稳定   | 简单但效率低，适合小规模数据或基本有序数据。           |
| **选择排序** | O(n2)O(n^2)O(n2) | O(n2)O(n^2)O(n2) | O(n2)O(n^2)O(n2) | O(1)O(1)O(1) | 不稳定 | 每次选择未排序部分的最小值，交换次数少但比较次数固定。 |
| **插入排序** | O(n)O(n)O(n)     | O(n2)O(n^2)O(n2) | O(n2)O(n^2)O(n2) | O(1)O(1)O(1) | 稳定   | 对部分有序数据高效，小规模数据表现优。                 |

------

### 2. **高效排序算法**

| 算法         | 最好时间复杂度              | 平均时间复杂度              | 最坏时间复杂度              | 空间复杂度              | 稳定性 | 特点                                             |
| ------------ | --------------------------- | --------------------------- | --------------------------- | ----------------------- | ------ | ------------------------------------------------ |
| **快速排序** | O(nlog⁡n)O(n \log n)O(nlogn) | O(nlog⁡n)O(n \log n)O(nlogn) | O(n2)O(n^2)O(n2)            | O(log⁡n)O(\log n)O(logn) | 不稳定 | 平均性能最优，但最坏情况（如已排序数据）效率低。 |
| **归并排序** | O(nlog⁡n)O(n \log n)O(nlogn) | O(nlog⁡n)O(n \log n)O(nlogn) | O(nlog⁡n)O(n \log n)O(nlogn) | O(n)O(n)O(n)            | 稳定   | 稳定且时间复杂度稳定，但需额外空间。             |
| **堆排序**   | O(nlog⁡n)O(n \log n)O(nlogn) | O(nlog⁡n)O(n \log n)O(nlogn) | O(nlog⁡n)O(n \log n)O(nlogn) | O(1)O(1)O(1)            | 不稳定 | 原地排序，适合大规模数据，但缓存不友好。         |

------

### 3. **其他排序算法**

| 算法         | 时间复杂度                              | 空间复杂度           | 稳定性 | 特点                                                       |
| ------------ | --------------------------------------- | -------------------- | ------ | ---------------------------------------------------------- |
| **希尔排序** | O(n1.3)O(n^{1.3})O(n1.3) (依赖间隔)     | O(1)O(1)O(1)         | 不稳定 | 插入排序的改进版，性能优于O(n2)O(n^2)O(n2)但理论分析复杂。 |
| **计数排序** | O(n+k)O(n + k)O(n+k) (k为范围)          | O(k)O(k)O(k)         | 稳定   | 非比较排序，适用于整数且范围小的数据。                     |
| **基数排序** | O(d(n+b))O(d(n + b))O(d(n+b)) (d为位数) | O(n+b)O(n + b)O(n+b) | 稳定   | 按位排序，适合整数或字符串，但依赖位数和基数。             |

------

### **关键结论**

1. **时间复杂度**：
   - 归并、快速、堆排序平均为O(nlog⁡n)O(n \log n)O(nlogn)，适合大规模数据。
   - 基础排序算法（O(n2)O(n^2)O(n2)）仅适合小规模数据。
2. **空间复杂度**：
   - 归并排序需O(n)O(n)O(n)额外空间，快速排序递归栈为O(log⁡n)O(\log n)O(logn)，堆排序和希尔排序原地排序（O(1)O(1)O(1)）。
3. **稳定性**：
   - 稳定算法：冒泡、插入、归并、计数、基数排序。
   - 不稳定算法：选择、快速、堆、希尔排序。
4. **适用场景**：
   - **快速排序**：通用高效，但需避免最坏情况（如预排序数据）。
   - **归并排序**：稳定且适合外部排序（如大数据文件）。
   - **堆排序**：内存受限时优先选择（原地排序）。

如需更详细的实现或特定场景分析，可进一步探讨！