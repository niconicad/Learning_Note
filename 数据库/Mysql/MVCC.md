### **MVCC（多版本并发控制）详解**

MVCC（Multi-Version Concurrency Control）是一种数据库并发控制机制，通过维护数据的多个版本，实现读写操作的并发执行，提高数据库性能。以下是其核心原理和实现细节：

------

#### **1. MVCC的核心思想**

- **多版本共存**：同一数据在不同时间点存在多个版本，每个事务基于自己的“快照”读取数据。
- **读写分离**：读操作访问历史版本（快照读），写操作创建新版本（当前读），避免读写阻塞。
- **非锁定读**：读操作无需加锁，减少锁竞争，提高并发性能。

------

#### **2. MVCC的实现机制**

##### **(1) 隐藏字段**

InnoDB每行数据包含三个隐藏列：

- **`DB_TRX_ID`**：最近修改该行的事务ID。
- **`DB_ROLL_PTR`**：指向Undo Log中旧版本数据的指针。
- **`DB_ROW_ID`**（可选）：行唯一ID（无主键时自动生成）。

##### **(2) Undo Log（回滚日志）**

- **作用**：存储数据的历史版本，用于事务回滚和MVCC快照读。
- **版本链**：通过`DB_ROLL_PTR`将同一数据的多个版本连接成链表，头部是最新版本。

##### **(3) ReadView（读视图）**

决定事务能看到哪些数据版本，包含四个关键字段：

- **`creator_trx_id`**：创建该ReadView的事务ID。
- **`m_ids`**：当前活跃事务ID列表。
- **`min_trx_id`**：活跃事务中的最小ID。
- **`max_trx_id`**：下一个待分配的事务ID。

##### **(4) 可见性判断规则**

事务读取数据时，根据以下规则判断版本是否可见：

1. **`DB_TRX_ID < min_trx_id`**：版本已提交，可见。

2. **`DB_TRX_ID > max_trx_id`**：版本由未来事务创建，不可见。

3. **

   ```
   min_trx_id ≤ DB_TRX_ID < max_trx_id
   ```

   **：

   - 若`DB_TRX_ID`在`m_ids`中：版本未提交，不可见。
   - 否则：版本已提交，可见。

若当前版本不可见，则沿版本链回溯查找旧版本。

------

#### **3. MVCC与事务隔离级别**

- **读已提交（RC）**：每次查询生成新ReadView，可能读到其他事务已提交的修改（不可重复读）。
- **可重复读（RR）**：事务首次查询时生成ReadView并复用，保证多次读取结果一致（解决不可重复读，但可能幻读）。
- **串行化**：不使用MVCC，完全依赖锁实现串行执行。

------

#### **4. MVCC的工作流程示例**

1. **事务A（ID=100）**更新行数据，生成新版本并写入Undo Log，更新`DB_TRX_ID=100`。
2. **事务B（ID=200）**查询时生成ReadView，若`DB_TRX_ID=100`未提交（在`m_ids`中），则读取Undo Log中的旧版本。
3. **事务A提交后**，事务B的ReadView中`m_ids`不再包含100，后续查询可看到新版本。

------

#### **5. MVCC的优缺点**

- 优点：
  - 提高并发性能（读写不阻塞）。
  - 支持一致性非锁定读。
  - 减少死锁概率。
- 缺点：
  - 存储开销（需维护多版本）。
  - 长事务可能导致Undo Log堆积。

------

#### **6. 不同数据库的MVCC实现**

- **MySQL InnoDB**：通过隐藏列、Undo Log和ReadView实现。
- **PostgreSQL**：使用事务ID和元组可见性规则，通过VACUUM清理旧版本。

------

### **总结**

MVCC通过多版本和快照读机制，在保证事务隔离性的同时显著提升并发性能，是InnoDB实现高并发的核心技术。其核心在于**版本链**、**ReadView**和**可见性判断**的协同工作。

https://mp.weixin.qq.com/s/Xuoo2BmtXmgqNAMgfKV-PA