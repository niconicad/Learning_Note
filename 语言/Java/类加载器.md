在 Java 中，类加载器（**ClassLoader**）负责将 Java 类的字节码（.class 文件）从不同的来源加载到内存中，以便 JVM 执行。类加载器的工作就像是一个“搬运工”，它会把类的字节码从文件系统、网络等地方取出并加载到 JVM 中，供程序使用。

### **类加载器的工作原理**

1. **加载类**：类加载器从不同的位置加载字节码文件（通常是 `.class` 文件），这些文件包含了类的定义。
2. **验证类**：加载器会确保类的字节码符合 JVM 的要求，比如文件格式正确、类的结构合法等。
3. **准备类**：为类分配内存，并初始化静态变量。
4. **解析类**：连接类中的引用，确保它们指向正确的内存位置。
5. **初始化类**：如果类包含静态代码块或静态变量的初始化，它会在此时执行。

### **类加载器的类型**

Java 中有几种不同的类加载器，每个类加载器负责加载不同的类：

1. **启动类加载器（Bootstrap ClassLoader）**：
   - 这是最基本的类加载器，负责加载 Java 核心类库（比如 `java.lang.*`、`java.util.*` 等）。
   - 它直接与 JVM 实现相关，通常是由 C++ 编写的。
2. **扩展类加载器（Extension ClassLoader）**：
   - 它负责加载 `jre/lib/ext` 目录下的类库，或者指定的扩展目录中的类。
   - 例如一些常用的扩展库，像数据库驱动程序。
3. **系统类加载器（System ClassLoader，也叫应用类加载器）**：
   - 它负责加载应用程序的类路径（classpath）下的类，比如 `jar` 包和编译的 `.class` 文件。
   - 通常，你在项目中添加的第三方库和你自己编写的类都是由这个加载器加载的。
4. **自定义类加载器**：
   - 有时需要加载一些非传统的地方的类，比如从网络上加载类、从数据库加载类等，可以通过自定义类加载器来实现。
   - 这允许 Java 程序动态地加载和卸载类。

### **类加载器的加载过程**

假设我们有一个类 `A`，它需要通过类加载器加载。以下是大致流程：

1. 当 JVM 遇到需要加载类 `A` 的时候，首先会委托给 **父加载器** 来加载（遵循父加载器委托机制）。
2. 如果父加载器找不到，才会尝试由当前的加载器来加载类 `A`。
3. 在加载过程中，类加载器会首先检查类是否已经被加载，如果已加载，则直接使用，否则继续从文件系统、网络等地方获取类字节码并加载。
4. 加载完成后，类会被解析并初始化，最终变成 JVM 可执行的字节码。

### **父加载器委托机制**

在 Java 中，类加载器遵循 **父加载器委托模型**。意思是：

- 当一个类加载器收到加载类的请求时，它会先把这个请求传递给它的父加载器处理。
- 只有在父加载器无法加载时，才由当前加载器来加载这个类。

这种机制确保了类的加载顺序，从而避免了重复加载或者不一致的类定义。

### **总结：**

- **类加载器**：负责将 `.class` 文件加载到 JVM 中，供程序使用。
- **加载过程**：类加载器会从不同的地方加载字节码并验证、准备、解析类，最后进行初始化。
- **父加载器委托机制**：类加载器会先尝试让父加载器加载类，只有父加载器无法加载时，才由当前加载器加载。
- **三种常见的类加载器**：启动类加载器、扩展类加载器和系统类加载器，分别负责加载不同的类库。

通过类加载器，Java 程序能够动态加载和卸载类，支持更灵活的应用场景。

类加载器的工作通常是在 **运行时** 执行的。当程序执行到某个需要使用类的地方，JVM 才会开始通过类加载器加载该类。具体来说，类加载器的工作是在以下几个时刻进行的：

### 1. **首次使用类时（懒加载）**

- Java 的类加载机制是 **懒加载**（Lazy Loading）的，也就是说，只有当一个类被 **首次访问** 或者 **首次使用** 时，JVM 才会去加载这个类。
- 例如，当你调用一个类的构造函数、调用类中的静态方法、或访问类的静态字段时，JVM 会检查该类是否已经加载，如果没有加载，则会通过类加载器来加载它。

**举个例子**：

```java
public class Main {
    public static void main(String[] args) {
        // 这个时刻才会加载 A 类
        A a = new A();
    }
}

class A {
    // 构造函数和静态代码块会在类加载时执行
    static {
        System.out.println("Class A loaded");
    }

    public A() {
        System.out.println("A instance created");
    }
}
```

在这个例子中，类 `A` 会在 `new A()` 这一行执行时被加载。这就是类加载器的工作时机。

### 2. **通过反射使用类时**

- 如果你通过 Java 的反射机制来创建类的实例或访问类的方法，那么类也会在反射调用时进行加载。

**示例**：

```java
Class<?> clazz = Class.forName("A");  // 使用反射加载类 A
Object obj = clazz.newInstance();     // 通过反射创建 A 的实例
```

在这种情况下，`Class.forName("A")` 这一行会导致类 `A` 被加载。

### 3. **类加载器的委托过程中**

- 类加载器遵循 **父加载器委托机制**，即当类加载器需要加载一个类时，它会先尝试由其父类加载器去加载。如果父类加载器无法加载，那么才会尝试由当前类加载器加载。
- 这通常发生在加载一些依赖库、系统类时。例如，`java.lang.String` 类是由 **启动类加载器**（Bootstrap ClassLoader）加载的，而应用程序的类是由 **系统类加载器**（Application ClassLoader）加载的。

### 4. **动态代理类加载**

- 在某些情况下（例如，使用动态代理时），Java 会动态创建代理类，这些代理类是通过类加载器动态加载的，通常是在运行时通过反射、字节码操作等技术来生成。

### 5. **ClassLoader 进行热部署或动态加载时**

- 在一些特定场景下，比如 **插件系统** 或 **热部署**，你可能需要动态地加载、卸载类。在这种情况下，你的应用程序可能在运行时通过自定义类加载器来加载新的类。
- 这种方法通常用于大型应用，像 Spring、Java EE 或应用服务器会使用类加载器来动态加载不同版本的类。

### **总结**：

类加载器的工作通常是在运行时进行的，特别是在以下几种情况：

- **首次访问类时**：如调用类的构造函数、静态方法或静态字段。
- **通过反射访问类时**：通过 `Class.forName()` 或反射机制动态加载类。
- **父加载器委托加载时**：在类加载时，父加载器首先尝试加载类，只有父加载器无法加载时才会由当前加载器加载。
- **动态代理和插件系统**：在运行时生成和加载动态代理类或插件。