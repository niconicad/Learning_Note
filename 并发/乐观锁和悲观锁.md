乐观锁和悲观锁是两种常见的并发控制机制，用于解决多线程或分布式环境下的数据竞争问题。它们的设计思想和适用场景有显著差异，具体如下：

------

### **1. 悲观锁（Pessimistic Locking）**

- **核心思想**：假设并发操作必然导致冲突，因此在访问共享资源前**先加锁**，确保独占性。

- 实现方式：

  - **数据库层面**：通过`SELECT ... FOR UPDATE`、`UPDATE ... WHERE`等语句实现行锁或表锁。
  - **编程语言层面**：如Java的`synchronized`、`ReentrantLock`等独占锁。
  
- 特点：

  - **强一致性**：保证数据修改的独占性，避免脏写和不可重复读。
  - **性能开销**：加锁机制可能导致线程阻塞、死锁风险及高并发下的性能下降。
  
- 适用场景：

  - 写操作频繁，冲突概率高（如电商库存扣减、银行转账）。
- 需要强一致性的业务（如金融交易）。

------

### **2. 乐观锁（Optimistic Locking）**

- **核心思想**：假设并发冲突概率低，因此**不加锁**，仅在更新时检测数据是否被修改（通过版本号、时间戳或CAS机制）。

- 实现方式：

  - **版本号机制**：数据表中增加`version`字段，更新时校验版本是否一致。
- **CAS（Compare-And-Swap）**：原子操作比较内存值，若未被修改则更新（如Java的`AtomicInteger`）。
  - **时间戳**：通过时间戳判断数据是否过期。

- 特点：

  - **无阻塞**：读操作不受限，适合高并发读场景。
  - **冲突处理**：若检测到冲突，需回滚或重试（可能增加应用层复杂度）。
  
- 适用场景：

  - 读多写少，冲突概率低（如评论系统、配置更新）。
- 分布式系统（如Redis的`WATCH`命令）。

------

### **3. 关键区别**

| **维度**       | **悲观锁**             | **乐观锁**                 |
| -------------- | ---------------------- | -------------------------- |
| **加锁时机**   | 访问资源前加锁         | 更新时检测冲突             |
| **性能**       | 高并发下性能差（阻塞） | 高并发下性能优（无锁）     |
| **冲突处理**   | 通过锁阻塞其他线程     | 回滚或重试                 |
| **实现复杂度** | 简单（依赖数据库锁）   | 需额外逻辑（如版本号管理） |
| **适用场景**   | 写多读少、强一致性     | 读多写少、高并发           |

------

### **4. 如何选择？**

- **悲观锁**：适合写操作密集且冲突频繁的场景，如订单支付、库存扣减。
- **乐观锁**：适合读多写少或分布式系统，如社交媒体的点赞、配置更新。

------

### **5. 实际案例**

- 悲观锁示例（MySQL）：

  ```sql
  BEGIN;
  SELECT * FROM orders WHERE id = 1 FOR UPDATE; -- 加行锁
  UPDATE orders SET status = 'paid' WHERE id = 1;
  COMMIT;
  ```
  
- 乐观锁示例

  （Java + 版本号）：

  ```java
  // 更新前检查版本号
  UPDATE products SET stock = stock - 1, version = version + 1 
  WHERE id = 100 AND version = oldVersion;
  ```

------

总结：乐观锁和悲观锁各有优劣，选择时需权衡**并发性能**与**业务需求**。在高并发系统中，可结合两者（如先乐观锁检测冲突，失败后降级为悲观锁）。