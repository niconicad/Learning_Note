消息系统的模型主要分为以下几种，每种模型适用于不同的业务场景：

### **1. 点对点模型（Point-to-Point / Queue Model）**

- **定义**：生产者将消息发送到队列，消费者从队列中获取消息，每条消息只能被一个消费者消费。
- 特点：
  - **竞争消费**：多个消费者监听同一队列，但一条消息仅被一个消费者处理。
  - **消息删除**：消费后消息从队列移除，避免重复消费。
- **适用场景**：任务分发、订单处理等需确保消息仅处理一次的场景。

### **2. 发布/订阅模型（Publish/Subscribe Model）**

- **定义**：生产者将消息发布到主题（Topic），所有订阅该主题的消费者均能接收消息。
- 特点：
  - **广播消费**：一条消息可被多个消费者同时接收。
  - **消息持久化**：通常长期保留，支持离线消费者重新获取。
- **适用场景**：实时通知、日志收集、事件驱动架构。

### **3. 请求/响应模型（Request/Response Model）**

- **定义**：客户端发送请求消息，服务端处理并返回响应消息。
- **特点**：同步或异步通信，类似RPC（远程过程调用）。
- **适用场景**：API调用、微服务间通信。

### **4. 混合模型（Hybrid Model）**

- **定义**：结合点对点和发布/订阅的特性，支持一对一和一对多通信。
- **适用场景**：复杂业务需同时支持定向分发和广播。

### **5. 流模型（Stream Model）**

- **定义**：消息以连续流的形式传输，消费者实时处理数据流。
- **特点**：高吞吐、低延迟，支持窗口计算和聚合。
- **适用场景**：实时监控、大数据流处理（如Kafka Streams）。

### **6. 推拉模型（Push-Pull Model）**

- 定义：
  - **Push**：服务端主动推送数据给消费者（如WebSocket）。
  - **Pull**：消费者主动从服务端拉取数据（如HTTP轮询）。
- **适用场景**：实时消息推送（Push）或按需数据获取（Pull）。

### **7. 管道模型（Pipes and Filters Model）**

- **定义**：消息通过一系列过滤器（Filter）按流程处理，每个过滤器完成特定任务。
- **适用场景**：日志处理、数据清洗管道。

### **总结**

不同消息模型的选择取决于业务需求：

- **点对点**：确保消息唯一消费（如订单处理）。
- **发布/订阅**：广播消息（如新闻推送）。
- **流模型**：实时数据处理（如风控系统）。
   主流消息队列的支持情况：
- **Kafka**：发布/订阅 + 流模型。
- **RabbitMQ**：点对点 + 发布/订阅（通过Exchange）。
- **ZeroMQ**：推拉、请求/响应等灵活组合。