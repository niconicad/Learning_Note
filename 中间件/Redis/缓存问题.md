**缓存击穿、缓存穿透、缓存雪崩** 是缓存系统设计中常见的三种异常情况，可能导致数据库压力骤增甚至服务崩溃。以下是它们的定义、原因及解决方案：

------

### **1. 缓存击穿（Cache Breakdown）**

- **定义**：**某个热点Key突然失效**，同时大量并发请求直接打到数据库。

- **场景**：微博热搜、秒杀商品等热点数据过期瞬间。

- **原因**：

  - Key设置了过期时间，且恰好在高并发时失效。
  - 未使用互斥锁或逻辑过期策略。

- **解决方案**：

  - 

    互斥锁（Mutex Lock）

    ：

    - 第一个请求发现缓存失效时，加锁（如Redis的`SETNX`），从数据库加载数据后释放锁，其他请求等待。

    java

    复制

    ```java
    public String getData(String key) {
        String data = redis.get(key);
        if (data == null) {
            if (redis.setnx(key + ":lock", "1", 10)) { // 加锁
                data = db.query(key);                 // 查数据库
                redis.set(key, data, 3600);           // 重建缓存
                redis.del(key + ":lock");             // 释放锁
            } else {
                Thread.sleep(100);                    // 重试等待
                return getData(key);                  // 递归调用
            }
        }
        return data;
    }
    ```

  - 

    逻辑过期

    ：

    - 缓存永不过期，但存储一个额外字段（如`expireTime`），异步线程定期检查并更新。

------

### **2. 缓存穿透（Cache Penetration）**

- **定义**：**查询不存在的数据**（既不在缓存也不在数据库），导致每次请求都穿透到数据库。

- **场景**：恶意攻击（如伪造不存在的ID）、业务逻辑漏洞。

- **原因**：

  - 非法请求未在缓存层拦截。
  - 数据库缺乏对无效请求的过滤机制。

- **解决方案**：

  - 

    布隆过滤器（Bloom Filter）

    ：

    - 在缓存前加一层布隆过滤器，快速判断Key是否存在。若过滤器返回“不存在”，则直接拒绝请求。

    python

    复制

    ```python
    from pybloom_live import BloomFilter
    bf = BloomFilter(capacity=100000, error_rate=0.001)
    for id in valid_ids:  # 预热布隆过滤器
        bf.add(id)
    
    def get_data(key):
        if key not in bf:  # 布隆过滤器拦截
            return None
        return redis.get(key) or db.query(key)
    ```

  - 

    缓存空值（Null Caching）

    ：

    - 对查询结果为空的Key，缓存一个短期的空值（如`redis.set(key, null, 60)`）。

  - 

    接口层校验

    ：

    - 对请求参数做合法性检查（如ID必须为数字、范围限制）。

------

### **3. 缓存雪崩（Cache Avalanche）**

- **定义**：**大量Key同时失效**或**缓存集群宕机**，导致请求全部涌向数据库。

- **场景**：缓存服务器重启、批量Key设置相同过期时间。

- **原因**：

  - 缓存集中过期（如凌晨批量刷新缓存）。
  - 缓存服务不可用（如Redis集群崩溃）。

- **解决方案**：

  - 

    差异化过期时间

    ：

    - 对Key的过期时间添加随机值（如`基础时间 + 随机1~5分钟`）。

    java

    复制

    ```java
    int expireTime = 3600 + new Random().nextInt(300); // 基础1小时 + 随机5分钟
    redis.set(key, value, expireTime);
    ```

  - 

    多级缓存（Cache Hierarchy）

    ：

    - 本地缓存（Caffeine） + 分布式缓存（Redis） + 数据库，逐层降级。

  - 

    高可用架构

    ：

    - Redis集群（主从+哨兵）、异地多活。

  - 

    熔断降级

    ：

    - 使用Hystrix或Sentinel在数据库压力过大时触发熔断，返回默认值或错误页。

------

### **三者的区别总结**

| **问题**     | **触发条件**             | **核心影响**         | **典型解决方案**           |
| ------------ | ------------------------ | -------------------- | -------------------------- |
| **缓存击穿** | 单个热点Key失效          | 高并发请求压垮数据库 | 互斥锁、逻辑过期           |
| **缓存穿透** | 查询不存在的数据         | 无效请求消耗系统资源 | 布隆过滤器、缓存空值       |
| **缓存雪崩** | 大量Key同时失效/缓存宕机 | 数据库瞬时压力过大   | 差异化过期、多级缓存、熔断 |

------

### **最佳实践建议**

1. **监控与预警**：实时监控缓存命中率、数据库QPS，设置阈值告警。
2. **压测演练**：模拟高并发场景，验证缓存策略的可靠性。
3. **代码防御**：在数据访问层统一封装缓存逻辑（如Spring Cache注解+自定义切面）。

通过合理设计缓存策略，可以显著提升系统的抗并发能力和稳定性。